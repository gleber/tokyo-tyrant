.TH "INTRO" 3 "2009-02-04" "Man Page" "Tokyo Cabinet"


.SH TOKYO TYRANT: NETWORK INTERFACE OF TOKYO CABINET

.SH TABLE OF CONTENTS
Introduction
.br
Installation
.br
Server Programs
.br
Client Programs
.br
Remote Database API
.br
Lua Extension
.br
Protocol
.br
Tutorial
.br
License
.br

.SH INTRODUCTION
.PP
Tokyo Tyrant is a package of network interface to the DBM called Tokyo Cabinet.  Though the DBM has high performance, you might bother in case that multiple processes share the same database, or remote processes access the database.  Thus, Tokyo Tyrant is provided for concurrent and remote connections to Tokyo Cabinet.  It is composed of the server process managing a database and its access library for client applications.  The server can embed Lua, a lightweight script language so that you can define arbitrary operations of the database.
.PP
The server features high concurrency due to thread\-pool modeled implementation and the epoll/kqueue mechanism of the modern Linux/*BSD kernel.  The server and its clients communicate with each other by simple binary protocol on TCP/IP.  Protocols compatible with memcached and HTTP/1.1 are also supported so that almost all principal platforms and programming languages can use Tokyo Tyrant.  High availability and high integrity are also featured due to such mechanisms as hot backup, update logging, and replication.
.PP
As for now, the server works on Linux, FreeBSD, Mac OS X only.

.SH INSTALLATION
.PP
Install the latest version of Tokyo Cabinet beforehand and get the package of Tokyo Tyrant.
.PP
When an archive file of Tokyo Tyrant is extracted, change the current working directory to the generated directory and perform installation.
.PP
Run the configuration script.  To enable the Lua extension, add the `\-\-enable\-lua' option.
.PP
Build programs.
.PP
Install programs.  This operation must be carried out by the root user.
.PP
When a series of work finishes, the following files will be installed.
.PP
To test the server, perform the following command.  To finish it, press Ctrl\-C on the terminal.
.PP
To test the client connecting to the above running server, perform the following command on another terminal.

.SH SERVER PROGRAMS

.SH TTSERVER
.PP
The command `\fBttserver\fR' runs the server managing a database instance.  Because the database is treated by the abstract API of Tokyo Cabinet, you can choose the scheme on start\-up of the server.  Supported schema are on\-memory hash database, on\-memory tree database, hash database, and B+ tree database.  This command is used in the following format.  `\fIdbname\fR' specifies the database name.  If it is omitted, on\-memory hash database is specified.
.PP
.RS
.br
\fBttserver \fR[\fB\-host \fIname\fB\fR]\fB \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-th\fInum\fB \fInum\fB\fR]\fB \fR[\fB\-tout \fInum\fB\fR]\fB \fR[\fB\-dmn\fR]\fB \fR[\fB\-pid \fIpath\fB\fR]\fB \fR[\fB\-log \fIpath\fB\fR]\fB \fR[\fB\-ld\fR|\fB\-le\fR]\fB \fR[\fB\-ulog \fIpath\fB\fR]\fB \fR[\fB\-ulim \fInum\fB\fR]\fB \fR[\fB\-uas\fR]\fB \fR[\fB\-sid \fInum\fB\fR]\fB \fR[\fB\-mhost \fIname\fB\fR]\fB \fR[\fB\-mport \fInum\fB\fR]\fB \fR[\fB\-rts \fIpath\fB\fR]\fB \fR[\fB\-ext \fIpath\fB\fR]\fB \fR[\fB\-mask \fIexpr\fB\fR]\fB \fR[\fB\fIdbname\fB\fR]\fB\fR
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-host \fIname\fR\fR : specify the host name or the address of the server.  By default, every network address is bound.
.br
\fB\-port \fInum\fR\fR : specify the port number.  By default, it is 1978.
.br
\fB\-thnum \fInum\fR\fR : specify the number of worker threads.  By default, it is 8.
.br
\fB\-tout \fInum\fR\fR : specify the timeout of each session in seconds.  By default, no timeout is specified.
.br
\fB\-dmn\fR : work as a daemon process.
.br
\fB\-pid \fIpath\fR\fR : output the process ID into the file.
.br
\fB\-log \fIpath\fR\fR : output log messages into the file.
.br
\fB\-ld\fR : log debug messages also.
.br
\fB\-le\fR : log error messages only.
.br
\fB\-ulog \fIpath\fR\fR : specify the update log directory.
.br
\fB\-ulim \fInum\fR\fR : specify the limit size of each update log file.
.br
\fB\-uas\fR : use asynchronous I/O for the update log.
.br
\fB\-sid \fInum\fR\fR : specify the server ID.
.br
\fB\-mhost \fIname\fR\fR : specify the host name of the replication master server.
.br
\fB\-mport \fInum\fR\fR : specify the port number of the replication master server.
.br
\fB\-rts \fIpath\fR\fR : specify the replication time stamp file.
.br
\fB\-ext \fIpath\fR\fR : specify the script language extension file.
.br
\fB\-mask \fIexpr\fR\fR : specify the names of forbidden commands.
.br
\fB\-unmask \fIexpr\fR\fR : specify the names of allowed commands.
.br
.RE
.PP
To terminate the server normally, send SIGINT or SIGTERM to the process.  It is okay to press Ctrl\-C on the controlling terminal.  To restart the server, send SIGHUP to the process.  If the port number is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.  This command returns 0 on success, another on failure.
.PP
The naming convention of the database is specified by the abstract API of Tokyo Cabinet.  If the name is "*", the database will be an on\-memory hash database.  If it is "+", the database will be an on\-memory tree database.  If its suffix is ".tch", the database will be a hash database.  If its suffix is ".tcb", the database will be a B+ tree database.  If its suffix is ".tcf", the database will be a fixed\-length database.  If its suffix is ".tct", the database will be a table database.  Otherwise, this function fails.  Tuning parameters can trail the name, separated by "#".  Each parameter is composed of the name and the value, separated by "=".  On\-memory hash database supports "bnum", "capnum", and "capsiz".  On\-memory tree database supports "capnum" and "capsiz".  Hash database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", and "xmsiz".  B+ tree database supports "mode", "lmemb", "nmemb", "bnum", "apow", "fpow", "opts", "lcnum", "ncnum", and "xmsiz".  Fixed\-length database supports "mode", "width", and "limsiz".  Table database supports "mode", "bnum", "apow", "fpow", "opts", "rcnum", "lcnum", "ncnum", "xmsiz", and "idx".  The tuning parameter "capnum" specifies the capacity number of records.  "capsiz" specifies the capacity size of using memory.  Records spilled the capacity are removed by the storing order.  "mode" can contain "w" of writer, "r" of reader, "c" of creating, "t" of truncating, "e" of no locking, and "f" of non\-blocking lock.  The default mode is relevant to "wc".  "opts" can contains "l" of large option, "d" of Deflate option, "b" of BZIP2 option, and "t" of TCBS option.  "idx" specifies the column name of an index and its type separated by ":".  For example, "casket.tch#bnum=1000000#opts=ld" means that the name of the database file is "casket.tch", and the bucket number is 1000000, and the options are large and Deflate.
.PP
The command mask expression is a list of command names separated by ",".  For example, "out,vanish,copy" means a set of "out", "vanish", and "copy".  Commands of the memcached compatible protocol and the HTTP compatible protocol are also forbidden or allowed, related by the mask of each original command.  Moreover, there are meta expressions.  "all" means all commands.  "allorg" means all commands of the original binary protocol.  "allmc" means all commands of the memcached compatible protocol.  "allhttp" means all commands of the HTTP compatible protocol.  "allread" is the abbreviation of `get', `mget', `vsiz', `iterinit', `iternext', `fwmkeys', `rnum', `size', and `stat'.  "allwrite" is the abbreviation of `put', `putkeep', `putcat', `putshl', `putnr', `out', `addint', `adddouble', `vanish', and `misc'.  "allmanage" is the abbreviation of `sync', `copy', `restore', and `setmst'.  "repl" means replication as master.  "slave" means replication as slave.

.SH TTSERVCTL
.PP
The command `\fBttservctl\fR' is the startup script of the server.  It can be called by the RC script of the bootstrap process of the operating system.  This command is used in the following format.
.PP
.RS
.br
\fBttservctl start\fR
.RS
Startup the server.
.RE
.br
\fBttservctl stop\fR
.RS
Stop the server.
.RE
.br
\fBttservctl restart\fR
.RS
Restart the server.
.RE
.br
\fBttservctl hup\fR
.RS
Send HUP signal to the server for log rotation.
.RE
.RE
.PP
The database is placed as "/var/ttserver/casket.tch".  The log and related files are also placed in "/var/ttserver".  This command returns 0 on success, another on failure.

.SH TTULMGR
.PP
The command `\fBttulmgr\fR' is the utility to export and import the update log.  It is useful to filter the update log with such text utilities as `\fBgrep\fR' and `\fBsed\fR'.  This command is used in the following format.  `\fIupath\fR' specifies the update log directory.
.PP
.RS
.br
\fBttulmgr export \fR[\fB\-ts \fInum\fB\fR]\fB \fR[\fB\-sid \fInum\fB\fR]\fB \fIupath\fB\fR
.RS
Export the update log as TSV text data to the standard output.
.RE
.br
\fBttulmgr import \fIupath\fB\fR
.RS
Import TSV text data from the standard input to the update log.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-ts \fInum\fR\fR : specify the beginning time stamp.
.br
\fB\-sid \fInum\fR\fR : specify the self server ID.
.br
.RE
.PP
This command returns 0 on success, another on failure.

.SH CLIENT PROGRAMS

.SH TCRTEST
.PP
The command `\fBtcrtest\fR' is a utility for facility test and performance test.  This command is used in the following format.  `\fIhost\fR' specifies the host name of the server.  `\fIrnum\fR' specifies the number of iterations.
.PP
.RS
.br
\fBtcrtest write \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-cnum \fInum\fB\fR]\fB \fR[\fB\-nr\fR]\fB \fR[\fB\-rnd\fR]\fB \fIhost\fB \fIrnum\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtcrtest read \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-cnum \fInum\fB\fR]\fB \fR[\fB\-mul \fInum\fB\fR]\fB \fR[\fB\-rnd\fR]\fB \fIhost\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtcrtest remove \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-cnum \fInum\fB\fR]\fB \fR[\fB\-rnd\fR]\fB \fIhost\fB\fR
.RS
Remove all records of the database above.
.RE
.br
\fBtcrtest rcat \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-cnum \fInum\fB\fR]\fB \fR[\fB\-shl \fInum\fB\fR]\fB \fR[\fB\-dai\fR|\fB\-dad\fR]\fB \fR[\fB\-ext \fIname\fB\fR]\fB \fR[\fB\-xlr\fR|\fB\-xlg\fR]\fB \fIhost\fB \fIrnum\fB\fR
.RS
Store records with partway duplicated keys using concatenate mode.
.RE
.br
\fBtcrtest misc \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-cnum \fInum\fB\fR]\fB \fIhost\fB \fIrnum\fB\fR
.RS
Perform miscellaneous test of various operations.
.RE
.br
\fBtcrtest wicked \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-cnum \fInum\fB\fR]\fB \fIhost\fB \fIrnum\fB\fR
.RS
Perform updating operations of list and map selected at random.
.RE
.br
\fBtcrtest table \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-cnum \fInum\fB\fR]\fB \fIhost\fB \fIrnum\fB\fR
.RS
Perform miscellaneous test of the table extension.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-port \fInum\fR\fR : specify the port number.
.br
\fB\-cnum \fInum\fR\fR : specify the number of connections.
.br
\fB\-nr\fR : use the function `tcrdbputnr' instead of `tcrdbput'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-mul \fInum\fR\fR : specify the number of records for the mget command.
.br
\fB\-shl \fInum\fR\fR : use `tcrdbputshl' and specify the width.
.br
\fB\-dai\fR : use `tcrdbaddint' instead of `tcrdbputcat'.
.br
\fB\-dad\fR : use `tcrdbadddouble' instead of `tcrdbputcat'.
.br
\fB\-ext \fIname\fR\fR : call a script language extension function.
.br
\fB\-xlr\fR : perform record locking.
.br
\fB\-xlg\fR : perform global locking.
.br
.RE
.PP
If the port number is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.  This command returns 0 on success, another on failure.

.SH TCRMTTEST
.PP
The command `\fBtcrmttest\fR' is a utility for facility test under multi\-thread situation.  This command is used in the following format.  `\fIhost\fR' specifies the host name of the server.  `\fIrnum\fR' specifies the number of iterations.
.PP
.RS
.br
\fBtcrmttest write \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-tnum \fInum\fB\fR]\fB \fR[\fB\-nr\fR]\fB \fR[\fB\-rnd\fR]\fB \fR[\fB\-ext \fIname\fB\fR]\fB \fIhost\fB \fIrnum\fB\fR
.RS
Store records with keys of 8 bytes.  They change as `00000001', `00000002'...
.RE
.br
\fBtcrmttest read \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-tnum \fInum\fB\fR]\fB \fR[\fB\-mul \fInum\fB\fR]\fB \fIhost\fB\fR
.RS
Retrieve all records of the database above.
.RE
.br
\fBtcrmttest remove \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-tnum \fInum\fB\fR]\fB \fIhost\fB\fR
.RS
Remove all records of the database above.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-port \fInum\fR\fR : specify the port number.
.br
\fB\-tnum \fInum\fR\fR : specify the number of running threads.
.br
\fB\-nr\fR : use the function `tcrdbputnr' instead of `tcrdbput'.
.br
\fB\-rnd\fR : select keys at random.
.br
\fB\-ext \fIname\fR\fR : call a script language extension function.
.br
\fB\-mul \fInum\fR\fR : specify the number of records for the mget command.
.br
.RE
.PP
If the port number is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.  This command returns 0 on success, another on failure.

.SH TCRMGR
.PP
The command `\fBtcrmgr\fR' is a utility for test and debugging of the remote database API and its applications.  `\fIhost\fR' specifies the host name of the server.  `\fIkey\fR' specifies the key of a record.  `\fIvalue\fR' specifies the value of a record.  `\fIfunc\fR specifies the name of the function.  `\fIarg\fR' specifies the arguments of the function.  `\fIdpath\fR' specifies the destination file.  `\fIfile\fR' specifies the input file.  `\fIupath\fR' specifies the update log directory.  `\fImhost\fR' specifies the host name of the replication master.  `\fIurl\fR' specifies the target URL.
.PP
.RS
.br
\fBtcrmgr inform \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-st\fR]\fB \fIhost\fB\fR
.RS
Print miscellaneous information to the standard output.
.RE
.br
\fBtcrmgr put \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-dk\fR|\fB\-dc\fR]\fB \fIhost\fB \fIkey\fB \fIvalue\fB\fR
.RS
Store a record.
.RE
.br
\fBtcrmgr out \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fIhost\fB \fIkey\fB\fR
.RS
Remove a record.
.RE
.br
\fBtcrmgr get \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-pz\fR]\fB \fIhost\fB \fIkey\fB\fR
.RS
Print the value of a record.
.RE
.br
\fBtcrmgr mget \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-px\fR]\fB \fIhost\fB \fR[\fB\fIkey\fB...\fR]\fB\fR
.RS
Print keys and values of multiple records.
.RE
.br
\fBtcrmgr list \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-m \fInum\fB\fR]\fB \fR[\fB\-pv\fR]\fB \fR[\fB\-px\fR]\fB \fR[\fB\-fm \fIstr\fB\fR]\fB \fIhost\fB\fR
.RS
Print keys of all records, separated by line feeds.
.RE
.br
\fBtcrmgr ext \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-xlr\fR|\fB\-xlg\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-px\fR]\fB \fIhost\fB \fIfunc\fB \fR[\fB\fIkey\fB \fR[\fB\fIvalue\fB\fR]\fB\fR]\fB\fR
.RS
Call a script language extension function.
.RE
.br
\fBtcrmgr sync \fR[\fB\-port \fInum\fB\fR]\fB \fIhost\fB\fR
.RS
Synchronize updated contents with the database file.
.RE
.br
\fBtcrmgr vanish \fR[\fB\-port \fInum\fB\fR]\fB \fIhost\fB\fR
.RS
Remove all records.
.RE
.br
\fBtcrmgr copy \fR[\fB\-port \fInum\fB\fR]\fB \fIhost\fB \fIdpath\fB\fR
.RS
Copy the database file.
.RE
.br
\fBtcrmgr misc \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-mnu\fR]\fB \fR[\fB\-sx\fR]\fB \fR[\fB\-sep \fIchr\fB\fR]\fB \fR[\fB\-px\fR]\fB \fIhost\fB \fIfunc\fB \fR[\fB\fIarg\fB...\fR]\fB\fR
.RS
Call a versatile function for miscellaneous operations.
.RE
.br
\fBtcrmgr importtsv \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-nr\fR]\fB \fR[\fB\-sc\fR]\fB \fIhost\fB \fR[\fB\fIfile\fB\fR]\fB\fR
.RS
Store records of TSV in each line of a file.
.RE
.br
\fBtcrmgr restore \fR[\fB\-port \fInum\fB\fR]\fB \fIhost\fB \fIupath\fB\fR
.RS
Restore the database with update log.
.RE
.br
\fBtcrmgr setmst \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-mport \fInum\fB\fR]\fB \fIhost\fB \fR[\fB\fImhost\fB\fR]\fB\fR
.RS
Set the replication master.
.RE
.br
\fBtcrmgr repl \fR[\fB\-port \fInum\fB\fR]\fB \fR[\fB\-ts \fInum\fB\fR]\fB \fR[\fB\-sid \fInum\fB\fR]\fB \fR[\fB\-ph\fR]\fB \fIhost\fB\fR
.RS
Replicate the update log.
.RE
.br
\fBtcrmgr http \fR[\fB\-ah \fIname\fB \fIvalue\fB\fR]\fB \fR[\fB\-ih\fR]\fB \fIurl\fB\fR
.RS
Fetch the resource of a URL by HTTP.
.RE
.br
\fBtcrmgr version\fR
.RS
Print the version information of Tokyo Tyrant.
.RE
.RE
.PP
Options feature the following.
.PP
.RS
\fB\-port \fInum\fR\fR : specify the port number.
.br
\fB\-st\fR : print miscellaneous status data.
.br
\fB\-sx\fR : input data is evaluated as a hexadecimal data string.
.br
\fB\-sep \fIchr\fR\fR : specify the separator of the input data.
.br
\fB\-dk\fR : use the function `tchdbputkeep' instead of `tchdbput'.
.br
\fB\-dc\fR : use the function `tchdbputcat' instead of `tchdbput'.
.br
\fB\-px\fR : output data is converted into a hexadecimal data string.
.br
\fB\-pz\fR : do not append line feed at the end of the output.
.br
\fB\-m \fInum\fR\fR : specify the maximum number of the output.
.br
\fB\-pv\fR : print values of records also.
.br
\fB\-fm \fIstr\fR\fR : specify the prefix of keys.
.br
\fB\-xlr\fR : perform record locking.
.br
\fB\-xlg\fR : perform global locking.
.br
\fB\-mnu\fR : omit the update log.
.br
\fB\-nr\fR : use the function `tcrdbputnr' instead of `tcrdbput'.
.br
\fB\-sc\fR : normalize keys as lower cases.
.br
\fB\-mport \fInum\fR\fR : specify the port number of the replication master.
.br
\fB\-ts \fInum\fR\fR : specify the beginning time stamp.
.br
\fB\-sid \fInum\fR\fR : specify the self server ID.
.br
\fB\-ph\fR : print human\-readable data.
.br
\fB\-ah \fIname\fR \fIvalue\fR\fR : add a request header.
.br
\fB\-ih\fR : output response headers also.
.br
.RE
.PP
If the port number is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.  This command returns 0 on success, another on failure.

.SH REMOTE DATABASE API
.PP
Remote database is a set of interfaces to use an abstract database of Tokyo Cabinet, mediated by a server of Tokyo Tyrant.  See `\fBtcrdb.h\fR' for entire specification.

.SH DESCRIPTION
.PP
To use the remote database API, include `\fBtcrdb.h\fR' and related standard header files.  Usually, write the following description near the front of a source file.
.PP
.RS
.br
\fB#include <tcrdb.h>\fR
.br
\fB#include <stdlib.h>\fR
.br
\fB#include <stdbool.h>\fR
.br
\fB#include <stdint.h>\fR
.RE
.PP
Objects whose type is pointer to `\fBTCRDB\fR' are used to handle remote databases.  A remote database object is created with the function `\fBtcrdbnew\fR' and is deleted with the function `\fBtcrdbdel\fR'.  To avoid memory leak, it is important to delete every object when it is no longer in use.
.PP
Before operations to store or retrieve records, it is necessary to connect the remote database object to the server.  The function `\fBtcrdbopen\fR' is used to open a database connection and the function `\fBtcrdbclose\fR' is used to close the connection.

.SH API
.PP
The function `tcrdberrmsg' is used in order to get the message string corresponding to an error code.
.PP
.RS
.br
\fBconst char *tcrdberrmsg(int \fIecode\fB);\fR
.RS
`\fIecode\fR' specifies the error code.
.RE
.RS
The return value is the message string of the error code.
.RE
.RE
.PP
The function `tcrdbnew' is used in order to create a remote database object.
.PP
.RS
.br
\fBTCRDB *tcrdbnew(void);\fR
.RS
The return value is the new remote database object.
.RE
.RE
.PP
The function `tcrdbdel' is used in order to delete a remote database object.
.PP
.RS
.br
\fBvoid tcrdbdel(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RE
.PP
The function `tcrdbecode' is used in order to get the last happened error code of a remote database object.
.PP
.RS
.br
\fBint tcrdbecode(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
The return value is the last happened error code.
.RE
.RS
The following error code is defined: `TTESUCCESS' for success, `TTEINVALID' for invalid operation, `TTENOHOST' for host not found, `TTEREFUSED' for connection refused, `TTESEND' for send error, `TTERECV' for recv error, `TTEKEEP' for existing record, `TTENOREC' for no record found, `TTEMISC' for miscellaneous error.
.RE
.RE
.PP
The function `tcrdbopen' is used in order to open a remote database.
.PP
.RS
.br
\fBbool tcrdbopen(TCRDB *\fIrdb\fB, const char *\fIhost\fB, int \fIport\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIhost\fR' specifies the name or the address of the server.
.RE
.RS
`\fIport\fR' specifies the port number.  If it is not more than 0, UNIX domain socket is used and the path of the socket file is specified by the host parameter.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbclose' is used in order to close a remote database object.
.PP
.RS
.br
\fBbool tcrdbclose(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbput' is used in order to store a record into a remote database object.
.PP
.RS
.br
\fBbool tcrdbput(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcrdbput2' is used in order to store a string record into a remote object.
.PP
.RS
.br
\fBbool tcrdbput2(TCRDB *\fIrdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcrdbputkeep' is used in order to store a new record into a remote database object.
.PP
.RS
.br
\fBbool tcrdbputkeep(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcrdbputkeep2' is used in order to store a new string record into a remote database object.
.PP
.RS
.br
\fBbool tcrdbputkeep2(TCRDB *\fIrdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcrdbputcat' is used in order to concatenate a value at the end of the existing record in a remote database object.
.PP
.RS
.br
\fBbool tcrdbputcat(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcrdbputcat2' is used in order to concatenate a string value at the end of the existing record in a remote database object.
.PP
.RS
.br
\fBbool tcrdbputcat2(TCRDB *\fIrdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcrdbputshl' is used in order to concatenate a value at the end of the existing record and shift it to the left.
.PP
.RS
.br
\fBbool tcrdbputshl(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB, int \fIwidth\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
`\fIwidth\fR' specifies the width of the record.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcrdbputshl2' is used in order to concatenate a string value at the end of the existing record and shift it to the left.
.PP
.RS
.br
\fBbool tcrdbputshl2(TCRDB *\fIrdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB, int \fIwidth\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
`\fIwidth\fR' specifies the width of the record.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcrdbputnr' is used in order to store a record into a remote database object without response from the server.
.PP
.RS
.br
\fBbool tcrdbputnr(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcrdbputnr2' is used in order to store a string record into a remote object without response from the server.
.PP
.RS
.br
\fBbool tcrdbputnr2(TCRDB *\fIrdb\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcrdbout' is used in order to remove a record of a remote database object.
.PP
.RS
.br
\fBbool tcrdbout(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbout2' is used in order to remove a string record of a remote database object.
.PP
.RS
.br
\fBbool tcrdbout2(TCRDB *\fIrdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbget' is used in order to retrieve a record in a remote database object.
.PP
.RS
.br
\fBvoid *tcrdbget(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int *\fIsp\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbget2' is used in order to retrieve a string record in a remote database object.
.PP
.RS
.br
\fBchar *tcrdbget2(TCRDB *\fIrdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbget3' is used in order to retrieve records in a remote database object.
.PP
.RS
.br
\fBbool tcrdbget3(TCRDB *\fIrdb\fB, TCMAP *\fIrecs\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIrecs\fR' specifies a map object containing the retrieval keys.  As a result of this function, keys existing in the database have the corresponding values and keys not existing in the database are removed.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbvsiz' is used in order to get the size of the value of a record in a remote database object.
.PP
.RS
.br
\fBint tcrdbvsiz(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcrdbvsiz2' is used in order to get the size of the value of a string record in a remote database object.
.PP
.RS
.br
\fBint tcrdbvsiz2(TCRDB *\fIrdb\fB, const char *\fIkstr\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.RE
.PP
The function `tcrdbiterinit' is used in order to initialize the iterator of a remote database object.
.PP
.RS
.br
\fBbool tcrdbiterinit(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
The iterator is used in order to access the key of every record stored in a database.
.RE
.RE
.PP
The function `tcrdbiternext' is used in order to get the next key of the iterator of a remote database object.
.PP
.RS
.br
\fBvoid *tcrdbiternext(TCRDB *\fIrdb\fB, int *\fIsp\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The iterator can be updated by multiple connections and then it is not assured that every record is traversed.
.RE
.RE
.PP
The function `tcrdbiternext2' is used in order to get the next key string of the iterator of a remote database object.
.PP
.RS
.br
\fBchar *tcrdbiternext2(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  The iterator can be updated by multiple connections and then it is not assured that every record is traversed.
.RE
.RE
.PP
The function `tcrdbfwmkeys' is used in order to get forward matching keys in a remote database object.
.PP
.RS
.br
\fBTCLIST *tcrdbfwmkeys(TCRDB *\fIrdb\fB, const void *\fIpbuf\fB, int \fIpsiz\fB, int \fImax\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIpbuf\fR' specifies the pointer to the region of the prefix.
.RE
.RS
`\fIpsiz\fR' specifies the size of the region of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbfwmkeys2' is used in order to get forward matching string keys in a remote database object.
.PP
.RS
.br
\fBTCLIST *tcrdbfwmkeys2(TCRDB *\fIrdb\fB, const char *\fIpstr\fB, int \fImax\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIpstr\fR' specifies the string of the prefix.
.RE
.RS
`\fImax\fR' specifies the maximum number of keys to be fetched.  If it is negative, no limit is specified.
.RE
.RS
The return value is a list object of the corresponding keys.  This function does never fail and return an empty list even if no key corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbaddint' is used in order to add an integer to a record in a remote database object.
.PP
.RS
.br
\fBint tcrdbaddint(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, int \fInum\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is `INT_MIN'.
.RE
.RS
If the corresponding record exists, the value is treated as an integer and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcrdbadddouble' is used in order to add a real number to a record in a remote database object.
.PP
.RS
.br
\fBdouble tcrdbadddouble(TCRDB *\fIrdb\fB, const void *\fIkbuf\fB, int \fIksiz\fB, double \fInum\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object connected as a writer.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fInum\fR' specifies the additional value.
.RE
.RS
If successful, the return value is the summation value, else, it is `NAN'.
.RE
.RS
If the corresponding record exists, the value is treated as a real number and is added to.  If no record corresponds, a new record of the additional value is stored.
.RE
.RE
.PP
The function `tcrdbext' is used in order to call a function of the script language extension.
.PP
.RS
.br
\fBvoid *tcrdbext(TCRDB *\fIrdb\fB, const char *\fIname\fB, int \fIopts\fB, const void *\fIkbuf\fB, int \fIksiz\fB, const void *\fIvbuf\fB, int \fIvsiz\fB, int *\fIsp\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIname\fR' specifies the function name.
.RE
.RS
`\fIopts\fR' specifies options by bitwise or: `RDBXOLCKREC' for record locking, `RDBXOLCKGLB' for global locking.
.RE
.RS
`\fIkbuf\fR' specifies the pointer to the region of the key.
.RE
.RS
`\fIksiz\fR' specifies the size of the region of the key.
.RE
.RS
`\fIvbuf\fR' specifies the pointer to the region of the value.
.RE
.RS
`\fIvsiz\fR' specifies the size of the region of the value.
.RE
.RS
`\fIsp\fR' specifies the pointer to the variable into which the size of the region of the return value is assigned.
.RE
.RS
If successful, the return value is the pointer to the region of the value of the response.  `NULL' is returned on failure.
.RE
.RS
Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbext2' is used in order to call a function of the script language extension.
.PP
.RS
.br
\fBchar *tcrdbext2(TCRDB *\fIrdb\fB, const char *\fIname\fB, int \fIopts\fB, const char *\fIkstr\fB, const char *\fIvstr\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIname\fR' specifies the function name.
.RE
.RS
`\fIopts\fR' specifies options by bitwise or: `RDBXOLCKREC' for record locking, `RDBXOLCKGLB' for global locking.
.RE
.RS
`\fIkstr\fR' specifies the string of the key.
.RE
.RS
`\fIvstr\fR' specifies the string of the value.
.RE
.RS
If successful, the return value is the string of the value of the response.  `NULL' is returned on failure.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbsync' is used in order to synchronize updated contents of a remote database object with the file and the device.
.PP
.RS
.br
\fBbool tcrdbsync(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbvanish' is used in order to remove all records of a remote database object.
.PP
.RS
.br
\fBbool tcrdbvanish(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbcopy' is used in order to copy the database file of a remote database object.
.PP
.RS
.br
\fBbool tcrdbcopy(TCRDB *\fIrdb\fB, const char *\fIpath\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIpath\fR' specifies the path of the destination file.  If it begins with `@', the trailing substring is executed as a command line.
.RE
.RS
If successful, the return value is true, else, it is false.  False is returned if the executed command returns non\-zero code.
.RE
.RS
The database file is assured to be kept synchronized and not modified while the copying or executing operation is in progress.  So, this function is useful to create a backup file of the database file.
.RE
.RE
.PP
The function `tcrdbrestore' is used in order to restore the database file of a remote database object from the update log.
.PP
.RS
.br
\fBbool tcrdbrestore(TCRDB *\fIrdb\fB, const char *\fIpath\fB, uint64_t \fIts\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIpath\fR' specifies the path of the update log directory.  If it begins with `+', the trailing substring is treated as the path and consistency checking is omitted.
.RE
.RS
`\fIts\fR' specifies the beginning time stamp in microseconds.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbsetmst' is used in order to set the replication master of a remote database object from the update log.
.PP
.RS
.br
\fBbool tcrdbsetmst(TCRDB *\fIrdb\fB, const char *\fIhost\fB, int \fIport\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIhost\fR' specifies the name or the address of the server.  If it is `NULL', replication of the database is disabled.
.RE
.RS
`\fIport\fR' specifies the port number.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbrnum' is used in order to get the number of records of a remote database object.
.PP
.RS
.br
\fBuint64_t tcrdbrnum(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
The return value is the number of records or 0 if the object does not connect to any database server.
.RE
.RE
.PP
The function `tcrdbsize' is used in order to get the size of the database of a remote database object.
.PP
.RS
.br
\fBuint64_t tcrdbsize(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
The return value is the size of the database or 0 if the object does not connect to any database server.
.RE
.RE
.PP
The function `tcrdbstat' is used in order to get the status string of the database of a remote database object.
.PP
.RS
.br
\fBchar *tcrdbstat(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
The return value is the status message of the database or `NULL' if the object does not connect to any database server.  The message format is TSV.  The first field of each line means the parameter name and the second field means the value.
.RE
.RS
Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbmisc' is used in order to call a versatile function for miscellaneous operations of a remote database object.
.PP
.RS
.br
\fBTCLIST *tcrdbmisc(TCRDB *\fIrdb\fB, const char *\fIname\fB, int \fIopts\fB, const TCLIST *\fIargs\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIname\fR' specifies the name of the function.  All databases support "put", "out", "get", "putlist", "outlist", and "getlist".  "put" is to store a record.  It receives a key and a value, and returns an empty list.  "out" is to remove a record.  It receives a key, and returns an empty list.  "get" is to retrieve a record.  It receives a key, and returns a list of the values.  "putlist" is to store records.  It receives keys and values one after the other, and returns an empty list.  "outlist" is to remove records.  It receives keys, and returns an empty list.  "getlist" is to retrieve records.  It receives keys, and returns keys and values of corresponding records one after the other.
.RE
.RS
`\fIopts\fR' specifies options by bitwise or: `RDBMONOULOG' for omission of the update log.
.RE
.RS
`\fIargs\fR' specifies a list object containing arguments.
.RE
.RS
If successful, the return value is a list object of the result.  `NULL' is returned on failure.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE

.SH API OF THE TABLE EXTENSION
.PP
The function `tcrdbtblput' is used in order to store a record into a remote database object.
.PP
.RS
.br
\fBbool tcrdbtblput(TCRDB *\fIrdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, TCMAP *\fIcols\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcols\fR' specifies a map object containing columns.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, it is overwritten.
.RE
.RE
.PP
The function `tcrdbtblputkeep' is used in order to store a new record into a remote database object.
.PP
.RS
.br
\fBbool tcrdbtblputkeep(TCRDB *\fIrdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, TCMAP *\fIcols\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcols\fR' specifies a map object containing columns.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If a record with the same key exists in the database, this function has no effect.
.RE
.RE
.PP
The function `tcrdbtblputcat' is used in order to concatenate columns of the existing record in a remote database object.
.PP
.RS
.br
\fBbool tcrdbtblputcat(TCRDB *\fIrdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB, TCMAP *\fIcols\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
`\fIcols\fR' specifies a map object containing columns.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
If there is no corresponding record, a new record is created.
.RE
.RE
.PP
The function `tcrdbtblout' is used in order to remove a record of a remote database object.
.PP
.RS
.br
\fBbool tcrdbtblout(TCRDB *\fIrdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object connected as a writer.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbtblget' is used in order to retrieve a record in a remote database object.
.PP
.RS
.br
\fBTCMAP *tcrdbtblget(TCRDB *\fIrdb\fB, const void *\fIpkbuf\fB, int \fIpksiz\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
`\fIpkbuf\fR' specifies the pointer to the region of the primary key.
.RE
.RS
`\fIpksiz\fR' specifies the size of the region of the primary key.
.RE
.RS
If successful, the return value is a map object of the columns of the corresponding record.  `NULL' is returned if no record corresponds.
.RE
.RS
Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbtblsetindex' is used in order to set a column index to a remote database object.
.PP
.RS
.br
\fBbool tcrdbtblsetindex(TCRDB *\fIrdb\fB, const char *\fIname\fB, int \fItype\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object connected as a writer.
.RE
.RS
`\fIname\fR' specifies the name of a column.  If the name of an existing index is specified, the index is rebuilt.  An empty string means the primary key.
.RE
.RS
`\fItype\fR' specifies the index type: `RDBITLEXICAL' for lexical string, `RDBITDECIMAL' for decimal string.  If it is `RDBITVOID', the index is removed.  If `RDBITKEEP' is added by bitwise or and the index exists, this function merely returns failure.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RS
Note that the setting indexes should be set after the database is opened.
.RE
.RE
.PP
The function `tcrdbtblgenuid' is used in order to generate a unique ID number of a remote database object.
.PP
.RS
.br
\fBint64_t tcrdbtblgenuid(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object connected as a writer.
.RE
.RS
The return value is the new unique ID number or \-1 on failure.
.RE
.RE
.PP
The function `tcrdbqrynew' is used in order to create a query object.
.PP
.RS
.br
\fBRDBQRY *tcrdbqrynew(TCRDB *\fIrdb\fB);\fR
.RS
`\fIrdb\fR' specifies the remote database object.
.RE
.RS
The return value is the new query object.
.RE
.RE
.PP
The function `tcrdbqrydel' is used in order to delete a query object.
.PP
.RS
.br
\fBvoid tcrdbqrydel(RDBQRY *\fIqry\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RE
.PP
The function `tcrdbqryaddcond' is used in order to add a narrowing condition to a query object.
.PP
.RS
.br
\fBvoid tcrdbqryaddcond(RDBQRY *\fIqry\fB, const char *\fIname\fB, int \fIop\fB, const char *\fIexpr\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
`\fIname\fR' specifies the name of a column.  An empty string means the primary key.
.RE
.RS
`\fIop\fR' specifies an operation type: `RDBQCSTREQ' for string which is equal to the expression, `RDBQCSTRINC' for string which is included in the expression, `RDBQCSTRBW' for string which begins with the expression, `RDBQCSTREW' for string which ends with the expression, `RDBQCSTRAND' for string which includes all tokens in the expression, `RDBQCSTROR' for string which includes at least one token in the expression, `RDBQCSTROREQ' for string which is equal to at least one token in the expression, `RDBQCSTRRX' for string which matches regular expressions of the expression, `RDBQCNUMEQ' for number which is equal to the expression, `RDBQCNUMGT' for number which is greater than the expression, `RDBQCNUMGE' for number which is greater than or equal to the expression, `RDBQCNUMLT' for number which is less than the expression, `RDBQCNUMLE' for number which is less than or equal to the expression, `RDBQCNUMBT' for number which is between two tokens of the expression, `RDBQCNUMOREQ' for number which is equal to at least one token in the expression.  All operations can be flagged by bitwise or: `RDBQCNEGATE' for negation, `RDBQCNOIDX' for using no index.
.RE
.RS
`\fIexpr\fR' specifies an operand exression.
.RE
.RE
.PP
The function `tcrdbqrysetorder' is used in order to set the order of a query object.
.PP
.RS
.br
\fBvoid tcrdbqrysetorder(RDBQRY *\fIqry\fB, const char *\fIname\fB, int \fItype\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
`\fIname\fR' specifies the name of a column.  An empty string means the primary key.
.RE
.RS
`\fItype\fR' specifies the order type: `RDBQOSTRASC' for string ascending, `RDBQOSTRDESC' for string descending, `RDBQONUMASC' for number ascending, `RDBQONUMDESC' for number descending.
.RE
.RE
.PP
The function `tcrdbqrysetmax' is used in order to set the maximum number of records of the result of a query object.
.PP
.RS
.br
\fBvoid tcrdbqrysetmax(RDBQRY *\fIqry\fB, int \fImax\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
`\fImax\fR' specifies the maximum number of records of the result.
.RE
.RE
.PP
The function `tcrdbqrysearch' is used in order to execute the search of a query object.
.PP
.RS
.br
\fBTCLIST *tcrdbqrysearch(RDBQRY *\fIqry\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
The return value is a list object of the primary keys of the corresponding records.  This function does never fail and return an empty list even if no record corresponds.
.RE
.RS
Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbqrysearchout' is used in order to remove each record corresponding to a query object.
.PP
.RS
.br
\fBbool tcrdbqrysearchout(RDBQRY *\fIqry\fB);\fR
.RS
`\fIqry\fR' specifies the query object of the database connected as a writer.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.RE
.PP
The function `tcrdbqrysearchget' is used in order to get records corresponding to the search of a query object.
.PP
.RS
.br
\fBTCLIST *tcrdbqrysearchget(RDBQRY *\fIqry\fB);\fR
.RS
`\fIqry\fR' specifies the query object.
.RE
.RS
The return value is a list object of zero separated columns of the corresponding records.
.RE
.RS
This function does never fail and return an empty list even if no record corresponds.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.
.RE
.RE
.PP
The function `tcrdbqryrescols' is used in order to get columns of a record in a search result.
.PP
.RS
.br
\fBTCMAP *tcrdbqryrescols(TCLIST *\fIres\fB, int \fIindex\fB);\fR
.RS
`\fIres\fR' specifies a list of zero separated columns of the search result.
.RE
.RS
`\fIindex\fR' the index of a element of the search result.
.RE
.RS
The return value is a map object containing columns.
.RE
.RS
Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.
.RE
.RE

.SH EXAMPLE CODE
.PP
The following code is an example to use a remote database.

.SH HOW TO USE THE LIBRARY
.PP
The API of C is available by programs conforming to the C89 (ANSI C) standard or the C99 standard.  As the header files of Tokyo Tyrant are provided as `\fBtcrdb.h\fR', applications should include it to use the API.  As the library is provided as `\fBlibtokyotyrant.a\fR' and `\fBlibtokyotyrant.so\fR' and they depends `\fBlibtokyocabinet.so\fR', `\fBlibz.so\fR', `\fBlibbz2.so\fR', `\fBlibresolv.so\fR', `\fBlibnsl.so\fR', `\fBlibdl.so\fR', `\fBlibrt.so\fR', `\fBlibpthread.so\fR', `\fBlibm.so\fR', and `\fBlibc.so\fR', linker options `\fB\-ltokyotyrant\fR', `\fB\-ltokyocabinet\fR', `\fB\-lz\fR', `\fB\-lbz2\fR', `\fB\-lresolv\fR', `\fB\-lnsl\fR', `\fB\-ldl\fR', `\fB\-lrt\fR', `\fB\-lpthread\fR', `\fB\-lm\fR', and `\fB\-lc\fR' are required for build command.  A typical build command is the following.
.PP
You can also use Tokyo Tyrant in programs written in C++.  Because each header is wrapped in C linkage (`\fBextern "C"\fR' block), you can simply include them into your C++ programs.

.SH LUA EXTENSION
.PP
The database server can starts reading a Lua script file by the `\fB\-ext\fR' option.  Clients can call functions defined in the script file by the `\fBtcrdbext\fR' function of the remote database API.

.SH USER\-DEFINED FUNCTIONS
.PP
You can define some arbitrary functions in the script file.  Each function receives two string parameters of the key and the value.  The return value is sent back to the client.  If the function returns `nil', the server send the error code to the client.
.PP
Two kinds of locking options are provided to `\fBtcrdbext\fR'.  One is global locking which means that only one thread can operate the function at the same time.  The other is record locking which means that only one thread can operate the record of the specified key at the same time.
.PP
Note that instances of Lua interpreter are handled separately by each native thread. Because global variables of Lua are not useful to share some data among native threads or sessions, shared data should be handled in the database or by the stash functions.

.SH BUILT\-IN FUNCTIONS
.PP
The following build\-in functions for database operations are available in user defined functions.  The type of `key' and `value' parameters should be string or number.  If number is given, it is converted as decimal string.
.PP
.RS
.br
\fB_log(\fImessage\fB, \fIlevel\fB)\fR
.RS
Print a message into the server log.
.RE
.RS
`\fImessage\fR' specifies the message string.
.RE
.RS
`\fIlevel\fR' specifies the log level; 0 for debug, 1 for information, 2 for error, 3 for system.  It can be omitted and the default value is 1.
.RE
.br
\fB_put(\fIkey\fB, \fIvalue\fB)\fR
.RS
Store a record.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
`\fIvalue\fR' specifies the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_putkeep(\fIkey\fB, \fIvalue\fB)\fR
.RS
Store a new record.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
`\fIvalue\fR' specifies the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_putcat(\fIkey\fB, \fIvalue\fB)\fR
.RS
Concatenate a value at the end of the existing record.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
`\fIvalue\fR' specifies the value.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_out(\fIkey\fB)\fR
.RS
Remove a record.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_get(\fIkey\fB)\fR
.RS
Retrieve a record.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
If successful, the return value is the value of the corresponding record.  `nil' is returned if no record corresponds.
.RE
.br
\fB_vsiz(\fIkey\fB)\fR
.RS
Get the size of the value of a record.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
If successful, the return value is the size of the value of the corresponding record, else, it is \-1.
.RE
.br
\fB_iterinit()\fR
.RS
Initialize the iterator.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_iternext()\fR
.RS
Get the next key of the iterator.
.RE
.RS
If successful, the return value is the next key, else, it is `nil'.  `nil' is returned when no record is to be get out of the iterator.
.RE
.br
\fB_addint(\fIkey\fB, \fIvalue\fB)\fR
.RS
Add an integer to a record.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
`\fIvalue\fR' specifies the value.
.RE
.RS
If successful, the return value is the summation value, else, it is `nil'.
.RE
.br
\fB_adddouble(\fIkey\fB, \fIvalue\fB)\fR
.RS
Add a real number to a record.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
`\fIvalue\fR' specifies the value.
.RE
.RS
If successful, the return value is the summation value, else, it is `nil'.
.RE
.br
\fB_vanish()\fR
.RS
Remove all records.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_rnum()\fR
.RS
Get the number of records.
.RE
.RS
The return value is the number of records.
.RE
.br
\fB_size()\fR
.RS
Get the size of the database file.
.RE
.RS
The return value is the size of the database file.
.RE
.br
\fB_misc(\fIname\fB, \fIargs\fB, ...)\fR
.RS
Call a versatile function for miscellaneous operations.
.RE
.RS
`\fIname\fR' specifies the name of the function.  If it begins with "$", the update log is omitted.
.RE
.RS
`\fIargs\fR' specifies an array of arguments.
.RE
.RS
If successful, the return value is an array of the result.  `nil' is returned on failure.
.RE
.br
\fB_foreach(\fIfunc\fB)\fR
.RS
Process each record atomically.
.RE
.RS
`\fIfunc\fR' the iterator function called for each record.  It receives two parameters of the key and the value, and returns true to continue iteration or false to stop iteration.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_stashput(\fIkey\fB, \fIvalue\fB)\fR
.RS
Store a record into the stash.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
`\fIvalue\fR' specifies the value.
.RE
.RS
The return value is always true.
.RE
.br
\fB_stashout(\fIkey\fB)\fR
.RS
Remove a record from the stash.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_stashget(\fIkey\fB)\fR
.RS
Retrieve a record in the stash.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
If successful, the return value is the value of the corresponding record.  `nil' is returned if no record corresponds.
.RE
.br
\fB_stashvanish()\fR
.RS
Remove all records of the stash.
.RE
.br
\fB_stashforeach(\fIfunc\fB)\fR
.RS
Process each record atomically of the stash.
.RE
.RS
`\fIfunc\fR' the iterator function called for each record.  It receives two parameters of the key and the value, and returns true to continue iteration or false to stop iteration.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_lock(\fIkey\fB)\fR
.RS
Lock an arbitrary key.
.RE
.RS
`\fIkey\fR' specifies the key.  The locked key should be unlocked in the same operation.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_unlock(\fIkey\fB)\fR
.RS
Unock an arbitrary key.
.RE
.RS
`\fIkey\fR' specifies the key.
.RE
.RS
If successful, the return value is true, else, it is false.
.RE
.br
\fB_pack(\fIformat\fB, \fIary\fB, ...)\fR
.RS
Serialize an array of numbers into a string.
.RE
.RS
`\fIformat\fR' specifies the format string.  It should be composed of conversion characters; `c' for int8_t, `C' for uint8_t, `s' for int16_t, `S' for uint16_t, `i' for int32_t, `I' for uint32_t, `l' for int64_t, `L' for uint64_t, `f' for float, `d' for double, `n' for uint16_t in network byte order, `N' for uint32_t in network byte order, `M' for uint64_t in network byte order, and `w' for BER encoding.  They can be trailed by a numeric expression standing for the iteration count or by `*' for the rest all iteration.
.RE
.RS
`\fIary\fR' specifies the array of numbers.
.RE
.RS
The return value is the serialized string.
.RE
.br
\fB_unpack(\fIformat\fB, \fIstr\fB)\fR
.RS
Deserialize a binary string into an array of numbers.
.RE
.RS
`\fIformat\fR' specifies the format string.  It should be composed of conversion characters as with `_pack'.
.RE
.RS
`\fIstr\fR' specifies the binary string.
.RE
.RS
The return value is the deserialized array.
.RE
.br
\fB_codec(\fImode\fB, \fIstr\fB)\fR
.RS
Encode or decode a string.
.RE
.RS
`\fImode\fR' specifies the encoding method; "url" for URL encoding, "~url" for URL decoding, "base" for Base64 encoding, "~base" for Base64 decoding, "hex" for hexadecimal encoding, "~hex" for hexadecimal decoding, "pack" for PackBits encoding, "~pack" for PackBits decoding, "tcbs" for TCBS encoding, "~tcbs" for TCBS decoding, "deflate" for Deflate encoding, "~deflate" for Deflate decoding, "gzip" for GZIP encoding, "~gzip" for GZIP decoding, "bzip" for BZIP2 encoding, "~bzip" for BZIP2 decoding, "xml" for XML escaping, "~xml" for XML unescaping.
.RE
.RS
`\fIstr\fR' specifies the string.
.RE
.RS
The return value is the encoded or decoded string.
.RE
.br
\fB_hash(\fImode\fB, \fIstr\fB)\fR
.RS
Get the hash value of a string.
.RE
.RS
`\fImode\fR' specifies the hash method; "md5" for MD5 in hexadecimal format, "md5raw" for MD5 in raw format, "crc32" for CRC32 checksum number.
.RE
.RS
`\fIstr\fR' specifies the string.
.RE
.RS
The return value is the hash value.
.RE
.br
\fB_ucs(\fIdata\fB)\fR
.RS
Convert a UTF\-8 string into a UCS\-2 array or its inverse.
.RE
.RS
`\fIdata\fR' specifies the target data.  If it is a string, convert it into a UCS\-array.  If it is an array, convert it into a UTF\-8 string.
.RE
.RS
The return value is the result data.
.RE
.br
\fB_dist(\fIastr\fB, \fIbstr\fB, \fIisutf\fB)\fR
.RS
Calculate the edit distance of two UTF\-8 strings.
.RE
.RS
`\fIastr\fR' specifies a string.
.RE
.RS
`\fIbstr\fR' specifies the other string.
.RE
.RS
`\fIisutf\fR' specifies whether to calculate cost by Unicode character.  If it is not defined, false is specified and calculate cost by ASCII character.
.RE
.RS
The return value is the edit distance which is known as the Levenshtein distance.
.RE
.br
\fB_isect(ary, ...)\fR
.RS
Calculate the intersection set of arrays.
.RE
.RS
`\fIary\fR' specifies the arrays.  Arbitrary number of arrays can be specified as the parameter list.
.RE
.RS
The return value is the array of the intersection set.
.RE
.br
\fB_union(ary, ...)\fR
.RS
Calculate the union set of arrays.
.RE
.RS
`\fIary\fR' specifies the arrays.  Arbitrary number of arrays can be specified as the parameter list.
.RE
.RS
The return value is the array of the union set.
.RE
.br
\fB_time()\fR
.RS
Get the time of day in seconds.
.RE
.RS
The return value is the time of day in seconds.  The accuracy is in microseconds.
.RE
.br
\fB_sleep(\fIsec\fB)\fR
.RS
Suspend execution for the specified interval.
.RE
.RS
`\fIsec\fR' specifies the interval in seconds.
.RE
.br
\fB_stat(\fIpath\fB)\fR
.RS
Get the status of a file.
.RE
.RS
`\fIpath\fR' specifies the path of the file.
.RE
.RS
If successful, the return value is a table containing status, else, it is `nil'.  There are keys of status name; "dev", "ino", "mode", "nlink", "uid", "gid", "rdev", "size", "blksize", "blocks", "atime", "mtime", "ctime", which have same meanings of the POSIX "stat" call.  Additionally, "_regular" for whether the file is a regular file, "_directory" for whether the file is a directory, "_readable" for whether the file is readable by the process, "_writable" for whether the file is writable by the process, "_executable" for whether the file is executable by the process, "_realpath" for the real path of the file, are supported.
.RE
.br
\fB_glob(\fIpattern\fB)\fR
.RS
Find pathnames matching a pattern.
.RE
.RS
`\fIpattern\fR' specifies the matching pattern.  "?" and "*" are meta characters.
.RE
.RS
The return value is an array of matched paths.  If no path is matched, an empty array is returned.
.RE
.br
\fB_remove(\fIpath\fB)\fR
.RS
Remove a file or a directory and its sub ones recursively.
.RE
.RS
`\fIpath\fR' specifies the path of the link.
.RE
.RS
If successful, it is true, else, it is false.
.RE
.br
\fB_mkdir(\fIpath\fB)\fR
.RS
Create a directory.
.RE
.RS
`\fIpath\fR' specifies the path of the directory.
.RE
.RS
If successful, it is true, else, it is false.
.RE
.RE
.PP
Built\-in functions, whose names start with "_", cannot be called directly by clients.  When the server starts, the function `\fB_begin\fR' is called implicitly if it has been defined.  When the server starts, the function `\fB_end\fR' is called implicitly if it has been defined.
.PP
The global variable `\fB_version\fR' contains the version information of the server.  The global variable `\fB_pid\fR' contains the process ID.  The global variable `\fB_sid\fR' contains the server ID.  The global variable `\fB_thnum\fR' contains the number of native threads.  The global variable `\fB_thid\fR' contains the ID number of each native thread.

.SH EXAMPLE CODE
.PP
The following code is an example to increment the record value and store as a decimal number string.  This function should be called with the record locking option to ensure atomicity.

.SH PROTOCOL
.PP
The protocol between the server and clients stands on TCP/IP.  By default, the service port is bound to every address of the local host and the port number is 1978.  Each session of the server and a client is composed of a request and a response.  Requests are classified into the following commands.  Structure of request and response is determined by the command.  The byte order of integer in request and response is big endian.
.PP
.RS
.br
\fBput: for the function `tcrdbput'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBvsiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR[\fBvbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x10
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
A 32\-bit integer standing for the length of the value
.RE
.RS
Arbitrary data of the key
.RE
.RS
Arbitrary data of the value
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBputkeep: for the function `tcrdbputkeep'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBvsiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR[\fBvbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x11
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
A 32\-bit integer standing for the length of the value
.RE
.RS
Arbitrary data of the key
.RE
.RS
Arbitrary data of the value
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBputcat: for the function `tcrdbputcat'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBvsiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR[\fBvbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x12
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
A 32\-bit integer standing for the length of the value
.RE
.RS
Arbitrary data of the key
.RE
.RS
Arbitrary data of the value
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBputshl: for the function `tcrdbputshl'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBvsiz:4\fR]\fB\fR[\fBwidth:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR[\fBvbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x13
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
A 32\-bit integer standing for the length of the value
.RE
.RS
A 32\-bit integer standing for the width
.RE
.RS
Arbitrary data of the key
.RE
.RS
Arbitrary data of the value
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBputnr: for the function `tcrdbputnr'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBvsiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR[\fBvbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x18
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
A 32\-bit integer standing for the length of the value
.RE
.RS
Arbitrary data of the key
.RE
.RS
Arbitrary data of the value
.RE
.br
\fBResponse: (none)\fR
.RE
.PP
.RS
.br
\fBout: for the function `tcrdbout'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x20
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
Arbitrary data of the key
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBget: for the function `tcrdbget'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x30
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
Arbitrary data of the key
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB(\fR[\fBvsiz:4\fR]\fB\fR[\fBvbuf:*\fR]\fB)\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
on success: A 32\-bit integer standing for the length of the value
.RE
.RS
on success: Arbitrary data of the value
.RE
.RE
.PP
.RS
.br
\fBmget: for the function `tcrdbget3'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBrnum:4\fR]\fB\fR[\fB{\fR[\fBksiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB}:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x31
.RE
.RS
A 32\-bit integer standing for the number of keys
.RE
.RS
iteration: A 32\-bit integer standing for the length of the key
.RE
.RS
iteration: Arbitrary data of the key
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR[\fBrnum:4\fR]\fB\fR[\fB{\fR[\fBksiz:4\fR]\fB\fR[\fBvsiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR[\fBvbuf:*\fR]\fB}:*\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
A 32\-bit integer standing for the number of records
.RE
.RS
iteration: A 32\-bit integer standing for the length of the key
.RE
.RS
iteration: A 32\-bit integer standing for the length of the value
.RE
.RS
iteration: Arbitrary data of the key
.RE
.RS
iteration: Arbitrary data of the value
.RE
.RE
.PP
.RS
.br
\fBvsiz: for the function `tcrdbvsiz'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x38
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
Arbitrary data of the key
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB(\fR[\fBvsiz:4\fR]\fB)\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
on success: A 32\-bit integer standing for the length of the value
.RE
.RE
.PP
.RS
.br
\fBiterinit: for the function `tcrdbiterinit'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x50
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBiternext: for the function `tcrdbiternext'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x51
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB(\fR[\fBksiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB)\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
on success: A 32\-bit integer standing for the length of the key
.RE
.RS
on success: Arbitrary data of the key
.RE
.RE
.PP
.RS
.br
\fBfwmkeys: for the function `tcrdbfwmkeys'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBpsiz:4\fR]\fB\fR[\fBmax:4\fR]\fB\fR[\fBpbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x58
.RE
.RS
A 32\-bit integer standing for the length of the prefix
.RE
.RS
A 32\-bit integer standing for the maximum number of keys to be fetched
.RE
.RS
Arbitrary data of the prefix
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR[\fBknum:4\fR]\fB\fR[\fB{\fR[\fBksiz:4\fR]\fB\fR[\fBkbuf:*\fR]\fB}:*\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
A 32\-bit integer standing for the number of keys
.RE
.RS
iteration: A 32\-bit integer standing for the length of the key
.RE
.RS
iteration: Arbitrary data of the key
.RE
.RE
.PP
.RS
.br
\fBaddint: for the function `tcrdbaddint'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBnum:4\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x60
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
A 32\-bit integer standing for the additional number
.RE
.RS
Arbitrary data of the key
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB(\fR[\fBsum:4\fR]\fB)\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
on success: A 32\-bit integer standing for the summation value
.RE
.RE
.PP
.RS
.br
\fBadddouble: for the function `tcrdbadddouble'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBinteg:8\fR]\fB\fR[\fBfract:8\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x61
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
A 64\-bit integer standing for the integral of the additional number
.RE
.RS
A 64\-bit integer standing for the trillionfold fractional of the additional number
.RE
.RS
Arbitrary data of the key
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB(\fR[\fBinteg:8\fR]\fB\fR[\fBfract:8\fR]\fB)\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
on success: A 64\-bit integer standing for the integral of the summation value
.RE
.RS
on success: A 64\-bit integer standing for the trillionfold fractional of the summation value
.RE
.RE
.PP
.RS
.br
\fBext: for the function `tcrdbext'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBnsiz:4\fR]\fB\fR[\fBopts:4\fR]\fB\fR[\fBksiz:4\fR]\fB\fR[\fBvsiz:4\fR]\fB\fR[\fBnbuf:*\fR]\fB\fR[\fBkbuf:*\fR]\fB\fR[\fBvbuf:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x68
.RE
.RS
A 32\-bit integer standing for the length of the function name
.RE
.RS
A 32\-bit integer standing for the options
.RE
.RS
A 32\-bit integer standing for the length of the key
.RE
.RS
A 32\-bit integer standing for the length of the value
.RE
.RS
Arbitrary data of the function name
.RE
.RS
Arbitrary data of the key
.RE
.RS
Arbitrary data of the value
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB(\fR[\fBrsiz:4\fR]\fB\fR[\fBrbuf:*\fR]\fB)\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
on success: A 32\-bit integer standing for the length of the result
.RE
.RS
on success: Arbitrary data of the result
.RE
.RE
.PP
.RS
.br
\fBsync: for the function `tcrdbsync'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x70
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBvanish: for the function `tcrdbvanish'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x71
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBcopy: for the function `tcrdbcopy'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBpsiz:4\fR]\fB\fR[\fBpath:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x72
.RE
.RS
A 32\-bit integer standing for the length of the path
.RE
.RS
Arbitrary data of the path
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBrestore: for the function `tcrdbrestore'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBpsiz:4\fR]\fB\fR[\fBts:8\fR]\fB\fR[\fBpath:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x73
.RE
.RS
A 32\-bit integer standing for the length of the path
.RE
.RS
A 64\-bit integer standing for the beginning time stamp in microseconds
.RE
.RS
Arbitrary data of the path
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBsetmst: for the function `tcrdbsetmst'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBhsiz:4\fR]\fB\fR[\fBport:4\fR]\fB\fR[\fBhost:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x78
.RE
.RS
A 32\-bit integer standing for the length of the host name
.RE
.RS
A 32\-bit integer standing for the port number
.RE
.RS
Arbitrary data of the host name
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RE
.PP
.RS
.br
\fBrnum: for the function `tcrdbrnum'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x80
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR[\fBrnum:8\fR]\fB\fR
.RS
An 8\-bit integer whose value is always 0
.RE
.RS
A 64\-bit integer standing for the number of records
.RE
.RE
.PP
.RS
.br
\fBsize: for the function `tcrdbsize'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x81
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR[\fBrnum:8\fR]\fB\fR
.RS
An 8\-bit integer whose value is always 0
.RE
.RS
A 64\-bit integer standing for the size of the database
.RE
.RE
.PP
.RS
.br
\fBstat: for the function `tcrdbstat'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x88
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR[\fBssiz:4\fR]\fB\fR[\fBsbuf:*\fR]\fB\fR
.RS
An 8\-bit integer whose value is always 0
.RE
.RS
A 32\-bit integer standing for the length of the status message
.RE
.RE
.PP
.RS
.br
\fBmisc: for the function `tcrdbmisc'\fR
.PP
.RS
.br
\fBRequest: \fR[\fBmagic:2\fR]\fB\fR[\fBnsiz:4\fR]\fB\fR[\fBopts:4\fR]\fB\fR[\fBrnum:4\fR]\fB\fR[\fBnbuf:*\fR]\fB\fR[\fB{\fR[\fBasiz:4\fR]\fB\fR[\fBabuf:*\fR]\fB}:*\fR]\fB\fR
.RS
Two bytes of the command ID: 0xC8 and 0x90
.RE
.RS
A 32\-bit integer standing for the length of the function name
.RE
.RS
A 32\-bit integer standing for the options
.RE
.RS
A 32\-bit integer standing for the number of arguments
.RE
.RS
Arbitrary data of the function name
.RE
.RS
iteration: A 32\-bit integer standing for the length of the argument
.RE
.RS
iteration: Arbitrary data of the argument
.RE
.br
\fBResponse: \fR[\fBcode:1\fR]\fB\fR[\fBrnum:4\fR]\fB\fR[\fB{\fR[\fBesiz:4\fR]\fB\fR[\fBebuf:*\fR]\fB}:*\fR]\fB\fR
.RS
An 8\-bit integer whose value is 0 on success or another on failure
.RE
.RS
A 32\-bit integer standing for the number of result elements
.RE
.RS
iteration: A 32\-bit integer standing for the length of the element
.RE
.RS
iteration: Arbitrary data of the element
.RE
.RE
.PP
To finish the session, the client can shutdown and close the socket at any time.  If not closed, the connection can be reused for the next session.  If protocol violation or some fatal error occurs, the server immediately breaks the session and closes the connection.
.PP
As for the memcached compatible protocol, the server implements the following commands; "set", "add", "replace", "get", "delete", "incr", "decr", "stats", "flush_all", "version", and "quit".  "noreply" options of update commands are also supported.  However, "flags", "exptime", and "cas unique" parameters are ignored.  The limitation size of each query is 8192 bytes except for the entity of the value.
.PP
As for the HTTP/1.1 compatible protocol, the server implements the following commands; "GET" (relevant to `tcrdbget'), "HEAD" (relevant to `tcrdbvsiz'), "PUT" (relevant to `tcrdbput'), "POST" (relevant to `tcrdbext'), and "DELETE" (relevant to `tcrdbout').  The URI of each request is treated as the key encoded by the URL encoding.  And the entity body is treated as the value.  However, headers except for "Connection" and "Content\-Length" are ignored.  The limitation size of each query is 8192 bytes.  "PUT" can have the header "X\-TT\-PDMODE" whose value is either of 1 (relevant to `tcrdbputkeep'), 2 (relevant to `tcrdbputcat'), or else (relevant to `tcrdbput').  "POST" should have the header "X\-TT\-XNAME" whose value stands for the function name to be called.  "POST" can have the header "X\-TT\-XOPTS" whose value stands for bitwise\-or options of 1 (record locking) and 2 (global locking).

.SH TUTORIAL

.SH BASIC USE
.PP
After installation of Tokyo Tyrant, you can start the server immediately by executing the command `\fBttserver\fR' in the terminal.  By default, the server listens to the port 1978 and serves as the accessor of an on\-memory hash database, which is useful to store cache data.
.PP
To test storing operations, execute the following commands in another terminal.  `\fBtcrmgr put\fR' calls the function `\fBtcrdbput\fR'.
.PP
To test retrieving operations, execute the following commands in another terminal.  `\fBtcrmgr get\fR' calls the function `\fBtcrdbget\fR'.
.PP
To retrieve multiple records at once, execute the following command.  `\fBtcrmgr mget\fR' calls the function `\fBtcrdbget3\fR'.
.PP
To terminate the server, input Ctrl\-C in the terminal of the server.
.PP
Next, let's run the server that handles a hash database, by specifying the file name whose suffix is `\fB.tch\fR'.
.PP
Store some records.
.PP
Terminate the server by Ctrl\-C, and then restart the server.
.PP
Check consistency of stored records.
.PP
Terminate the server by Ctrl\-C and remove the database, for the successive tutorial.

.SH DAEMON
.PP
To run the server as a daemon process, specify the option `\fB\-dmn\fR'.  Moreover, the option `\fB\-pid\fR' should be specified to record the process ID into a file.  Note that the current directory of the daemon process is changed to the root directory.  So, the file path parameter should be expressed as the absolute path.
.PP
To terminate the daemonized server, check the process ID from the file specified by `\fB\-pid\fR' and send the SIGTERM signal to the process.
.PP
To run the server by the RC script of the operating system, use `\fBttservctl\fR'.  As for most Linux distribution, append the following line to `\fB/etc/rc.local\fR'.
.PP
By default, the database file and the related files are placed under `\fB/var/ttserver\fR'.  Because `\fBttservctl\fR' is a tiny shell script, copy and edit it for your purpose.  Also, it is suitable to install the modified script into `\fB/etc/init.d\fR' and set symbolic links from `\fB/etc/rc3.d/S98ttserver\fR' and `\fB/etc/rc5.d/S98ttserver\fR'.

.SH BACKUP AND RECOVERY
.PP
Let's run the server again to continue this tutorial.
.PP
Store some records.
.PP
To back up the database file, indicate the destination path to the server by the command `\fBtcrmgr copy\fR'.  Note that the backup file is created on the local file system of the server (not on the client side).
.PP
Terminate the server by Ctrl\-C and remove the database.
.PP
Recover the database from the backup file and restart the server.
.PP
Check consistency of stored records.
.PP
Terminate the server by Ctrl\-C and remove the databases, for the successive tutorial.

.SH UPDATE LOG
.PP
Let's run the server with update logging enabled.  The option `\fB\-ulog\fR' specifies the directory to contain the update log files.
.PP
Store some records.
.PP
Terminate the server by Ctrl\-C and remove the database.
.PP
Escape the update log directoty and restart the server.
.PP
Restore the database from the escaped update log, by the command `\fBtcrmgr restore\fR' on the client side.
.PP
Check consistency of stored records.
.PP
Terminate the server by Ctrl\-C and remove the database, for the successive tutorial.

.SH REPLICATION
.PP
Replication is a mechanism to synchronize two or more database servers for high availability and high integrity.  The replication source server is called "master" and each destination server is called "slave".  Replication requires the following preconditions.
.PP
.RS
The master must record the update log.
.br
The master must specify the unique server ID.
.br
Each slave must record the update log because it may become the master when fail over.
.br
Each slave must specify the unique server ID because it may become the master when fail over.
.br
Each slave must specify the address and the port number of the master server.
.br
Each slave must specify the replication time stamp file.
.br
.RE
.PP
This section describes how to set up one master (at port 1978) and one slave (at port 1979) replication.  First, let's run the master server.
.PP
Next, let's run the slave server in another terminal.
.PP
Store some records into the master.
.PP
Check consistency of stored records in the master and the slave.
.PP
Let's simulate the case that the master is crashed.  Terminate the master by Ctrl\-C and remove the database file.
.PP
Terminate the slave by Ctrl\-C and restart it as the new master.
.PP
Add the new slave (at port 1980).
.PP
Check consistency of stored records in the new master and the new slave.
.PP
Terminate the two servers by Ctrl\-C and remove the database and related files.
.PP
Tokyo Tyrant supports "dual master" replication which realizes higher availability.  To do it, run two servers which replicate each other.

.SH SETTING REPLICATION ON DEMAND
.PP
You can set replication of the running database service without any downtime.  First, prepare the following script for backup operation and save it as "ttbackup.sh" with executable permission (0755).
.PP
Next, let's run the master with update log enabled.
.PP
Store a volume of records into the master.
.PP
Check consistency of stored records.
.PP
Backup the database.
.PP
Confirm that the backup file was saved as "casket\-1.tch.\fIxxxxx\fR" ("\fIxxxxx\fR" stands for the time stamp of the backup file).  Then, run the slave with the backup file.
.PP
Note that the above operation did not specify the master server to the slave.  For tutorial, let's simulate that some records are stored into the master by users while you are setting replication.
.PP
Check the difference between the master and the slave.
.PP
Specify the master to the slave so that replication will start and the difference will be resolved.
.PP
Confirm that the slave knows the master and the difference has been resolved.
.PP
Terminate the two servers by Ctrl\-C and remove the database and related files.

.SH TUNING
.PP
If you use a hash database, set the tuning parameter "#bnum=\fIxxx\fR" to improve performance.  It specifies the bucket number and should be more than the number of record to be stored.
.PP
If you use a B+ tree database, set the tuning parameters "#lcnum=\fIxxx\fR#bnum=\fIyyy\fR" to improve performance.  The former specifies the maximum number of leaf nodes to be cached.  It should be larger as long as the capacity of RAM on the system allows.  The latter specifies the bucket number and should be more than 1/128 of the number of records to be stored.
.PP
If huge number of clients access the server, make sure the limit number of file descriptors per process is cleared.  By default on most systems, it is set as 1024.  If so, use `\fBulimit\fR' to clear it.

.SH LUA EXTENSION
.PP
If you want more complex database operations than existing ones, use the Lua extension.  For example, prepare the following script and save it as "test.lua".  There is a function "fibonacci" which returns the Fibonacci number of a number of the key.
.PP
Let's start the server by making it read the script file.
.PP
Call the function from the client command.
.PP
Fibonacci numbers can be generated by another algorithm, which is naive and stateful.  Add the following script to "test.lua".  There is a function "fibnext" which returns the next Fibonacci number from the database.  The state information are stored in the database.
.PP
Then, restart the server and test the new algorithm.
.PP
As you see, the called function receives two string parameters of the key and the value.  The return value is sent back to the client.  You can use such built\-in functions for database operations as "_put", "_out", "_get", and so on.  There is a sample file `\fB/usr/local/share/tokyotyrant/senatus.lua\fR'.

.SH USING MEMCACHED CLIENT
.PP
This section describes how to use a memcached client library of Perl (Cache::Memcached) with Tokyo Tyrant.  Run the server of Tokyo Tyrant as usual.  And, the following script is a typical example.

.SH USING HTTP CLIENT
.PP
This section describes how to use an HTTP client library of Perl (LWP::UserAgent) with Tokyo Tyrant.  Run the server of Tokyo Tyrant as usual.  And, the following script is a typical example.

.SH LICENSE
.PP
Tokyo Tyrant is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License or any later version.
.PP
Tokyo Tyrant is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
.PP
You should have received a copy of the GNU Lesser General Public License along with Tokyo Tyrant (See the file `\fBCOPYING\fR'); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111\-1307 USA.
.PP
Tokyo Tyrant was written by Mikio Hirabayashi.  You can contact the author by e\-mail to `\fBmikio@users.sourceforge.net\fR'.

.SH SEE ALSO
.PP
.BR tcutil (3),
.BR tchdb (3),
.BR tcbdb (3)
.BR tcfdb (3)
.PP
Please see
.I http://tokyocabinet.sourceforge.net/spex-en.html
for detail.
